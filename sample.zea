
! zeasm:   the programming language (reverse polish notation)
! ! is comments (till the end of line)
! only digits, lower case letters and ,;:.?!"()'-
! 

include "std.zea"

! a module array of integer
data ar 0,1,2,3,4,5,? ! ? skips blank characters and comments
	6,7,8,9,?
	10,11,12;

!  module arrays of bytes 
data bar '-abcdefghijklmno'; 	! eight bytes

data str "abc";		! four bytes (strings are nul terminated)

func hello;

class myclass: 
! fields
var avalue;
var arrr;
var bptr;
wire logic; 	! for hardware desciption language

! methods
func new:
	sizeof myclass;
	new;
	set this;

	new 1024; 
	store this.arrr;
	load this.arrr;
	store this.bptr;  ! now arrr and bptr point to the same memory

	return this; ! we return the value on the compute stack
end;

func dispose:
	load this.arrr;
	delete;
	get this;
	delete;
	return 0;
end;

! recusive call while a is greater than zero
func methoda a,b:
	var aa;

	sub a 1; ! add sub mul div rem

	set aa;
	gt aa 0; ! eq ne lt gt le ge
	if true (
		this.methoda aa b;
		return;
	);
	return 0;
end;

end class; ! end of class myclass

func entry argc,argv:
	var tmp;	! a local variable (integer or pointer to data)
	class myclass obj;	! a pointer to object of type "myclass"
	var bs;		

	obj.new;	! instantiate an object (this pointer is null) and push
			! it to the stack
	set obj; 	! get it and assign it

	load obj.bptr;
	set bs;
	add bs 3;
	set bs;
	storeb bs 21; ! set byte three of obj.bptr to twenty-one

	loadb bs;
	set tmp;	      ! tmp equals  21

	obj.methoda 15 -3; ! call method
	drop;
	store obj.avalue 1;
	drop obj.dispose;	

	! invert bit zero of argc
	getb argc 0;
	if true (
		clrb argc 0;
	) false (
		setb argc 0;
	);

	!invert trit two of argc
	gett argc 2;
	if true (
		minust argc 2;
	) false (
		plust argc 2;
	) zero (
		! zerot argc 2;
	);

	gt argc 1;
	if true (
		println "too many arguments";
		exit -1;
	) else (
		eq argc 1;
		if true (
			println "hello world";
		) else (
			println "panic";
		);
	);

	! numerical constants
	drop mul 3 1000000000;
	! this is equivalent
	const 1000000000;
	const 3;
	mul;	
	drop; ! throw away the result of the multiplication


	set tmp "a string";
	print "program name equals ";
	println tmp;
	! array access
	varadd argv 0; 
	set tmp;
	load tmp;
	println;
	print "arg1: ";
	varadd argv 1; ! result is argv plus four
	println; 

	get tmp;
	loop (
		sub tmp 1;
		set tmp;
		gt tmp 0;
		if true (
			continue;
		) else (
			break;
		);
		printv tmp;
		println "";
	);

	hello tmp; 
	drop;

	print '-m-j--';	! byte string. - is zero, a is one 
			! binary : - abcde fghij klmno 
			! m thirteen, o  fifteen, j ten
		   	! we print  carriage return and new line characters
			! balanced ternary : zyx wvuts rqpon - abcde fghij klm

	set tmp "hello";
	set tmp '--';
	
	exit 0;
	return 0;
end;

! function definition
func hello value:
	println "the value of value is ";
	printv value;
	println "";
	return 0;
end;



